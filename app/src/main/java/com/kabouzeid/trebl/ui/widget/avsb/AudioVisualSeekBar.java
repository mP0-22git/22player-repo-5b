package com.kabouzeid.trebl.ui.widget.avsb;import android.animation.ValueAnimator;import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.LinearGradient;import android.graphics.Paint;import android.graphics.Shader;import android.os.Handler;import android.util.AttributeSet;import android.util.Log;import android.view.GestureDetector;import android.view.MotionEvent;import android.view.View;import android.view.animation.Interpolator;import android.view.animation.LinearInterpolator;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.dynamicanimation.animation.DynamicAnimation;import androidx.dynamicanimation.animation.FlingAnimation;import androidx.dynamicanimation.animation.FloatValueHolder;import androidx.interpolator.view.animation.FastOutLinearInInterpolator;import com.kabouzeid.trebl.App;import com.kabouzeid.trebl.coordinate.MCoordinate.MPoint;import com.kabouzeid.trebl.helper.MusicPlayerRemote;import com.kabouzeid.trebl.model.Song;import com.kabouzeid.trebl.util.InterpolatorUtil;import com.kabouzeid.trebl.util.Tool;/** * Created by dtrung98 on 09:05 AM 24 Jan 2018. */public class AudioVisualSeekBar extends View {    public static final String ACTION_SEEK_BAR_PARSING_FILE = "action_seek_bar_parsing_file";    OnSeekBarChangeListener mSeekBarListener;    void seekBarNotify(String action, String message, Object... data) {        // if(mSeekBarListener != null) mSeekBarListener.seekBarNotify(action, message, data);    }    public interface OnSeekBarChangeListener {        void onSeekBarSeekTo(AudioVisualSeekBar seekBar, int position);        void onSeekBarTouchDown(AudioVisualSeekBar seekBar);        void onSeekBarTouchUp(AudioVisualSeekBar seekBar);        void onSeekBarSeeking(int seekingValue);    }    public void setOnSeekBarChangeListener(OnSeekBarChangeListener listener) {        this.mSeekBarListener = listener;    }    // total time    protected int mSongDeclareDuration;    /**     * Controller call this method to update visual seek bar     */    public void setProgress(int progress) {        if (mState == State.ON_SEEKING) {            return;        }        if (progress >= 0) {            currentSeek = progress;        }        //Log.d(TAG, "setProgress: song = "+(mSong == null ? "null" : mSong.title)+", state = "+ mState+", progress = "+progress);        if (mState == State.VISUALIZING || !MusicPlayerRemote.isPlaying()) {            invalidate();        }    }    // Set duration    public void setSongDeclareDuration(int songDeclareDuration) {        this.mSongDeclareDuration = songDeclareDuration;    }    public static final String TAG = "AudioVisualSeekBar";    public AudioVisualSeekBar(Context context) {        super(context);        init(context);    }    public AudioVisualSeekBar(Context context, @Nullable AttributeSet attrs) {        super(context, attrs);        init(context);    }    public AudioVisualSeekBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {        super(context, attrs, defStyleAttr);        init(context);    }    private float amount_hide_paint = 0.25f;    private float amount_translucent_hide_paint = 0.15f;    private void init(Context context) {        // do the initialization here        setWillNotDraw(false);        mOneDp = Tool.getOneDps(getContext());        mPenStrokeWidth = 1.75f * mOneDp;        mPenDistance = 1f * mOneDp;        mSong = null;        processCommand(Command.BEGIN);        mHandler.postDelayed(mDrawInvalidationRunnable, (long) nextDelayedTime);        mActivePaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mActivePaint.setStyle(Paint.Style.FILL);        mActivePaint.setStrokeWidth((float) mPenStrokeWidth);        mTranslucentActivePaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mTranslucentActivePaint.setStyle(Paint.Style.FILL);        mTranslucentActivePaint.setStrokeWidth(mPenStrokeWidth);        mHidePaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mHidePaint.setStyle(Paint.Style.FILL);        mHidePaint.setStrokeWidth(mPenStrokeWidth);        mTranslucentHidePaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mTranslucentHidePaint.setStyle(Paint.Style.FILL);        mTranslucentHidePaint.setStrokeWidth(mPenStrokeWidth);        //     initDrawSetSize(getMeasuredWidth(),getMeasuredHeight());        initGestureDetector(context);        formatStateNothing();        formatPreparing();        formatSwitching();        formatVisualizing();    }    protected boolean mIsTouchDragging;    protected int mOffset;    protected int mOffsetGoal;    protected int mFlingVelocity;    protected void waveformFling(float vx) {        mActivePaint.setAlpha(255);        mTranslucentActivePaint.setAlpha((int) (amount_translucent_paint * 255));        mIsTouchDragging = false;        // mOffsetGoal = mOffset;        mFlingVelocity = (int) (vx);        doFlingTransition();    }    protected float mTouchDown;    protected int mTouchInitialOffset;    protected long mWaveformTouchStartMsec;    protected float tempCurrentWavePos = 0;    void waveformTouchDown(float x) {        mIsTouchDragging = true; // ngón tay đang nhấn vào màn hình        mTouchDown = x; // ghi lại vị trí nhấn        //mTouchInitialOffset = mOffset;        tempCurrentWavePos = currentWavePos; // ghi lại vị trí line hiện tại vào biến tạm        mFlingVelocity = 0; // set lại vận tốc        mWaveformTouchStartMsec = System.currentTimeMillis(); // ghi lại thời gian để kiểm tra click khi hết nhấn        /*         *         */        mActivePaint.setAlpha((int) ((1 - touchDownAlphaAdd) * 255));        mTranslucentActivePaint.setAlpha((int) ((amount_translucent_paint - touchDownAlphaAdd) * 255));    }    void waveformTouchMove(float x) {        //   mOffset = trap((int) (mTouchInitialOffset + (mTouchDown - x)));        //      Log.d (TAG,"onTouchMove : x = "+x+", mOffset = "+mOffset);        //  updateDisplay();        if (runningTrailer && va != null && va.isRunning()) va.cancel();        float deltaX = x - mTouchDown;        calculateAndInvalidate(tempCurrentWavePos - deltaX);    }    void waveformTouchUp() {        mActivePaint.setAlpha(255);        mTranslucentActivePaint.setAlpha((int) (amount_translucent_paint * 255));        mActivePaint.setAlpha(255);        mIsTouchDragging = false;        //mOffsetGoal = mOffset; // ?        //updateDisplay();        long elapsedMsec = System.currentTimeMillis() - mWaveformTouchStartMsec;        runningTrailer = false;        if (elapsedMsec < 300) { // A Quick Touch - A Click            //Log.d(TAG, "Elapsed");            startSlidingSeekBarEffect();            /*            if (mIsPlaying) {                int seekMsec = mWaveformView.pixelsToMillisecs((int) (mTouchDown + mOffset));                if (seekMsec >= mPlayStartMsec && seekMsec < mPlayEndMsec) {                    mPlayer.seekTo(seekMsec - mPlayStartOffset);                } else {                    handlePause();                }            } else {                onPlay((int) (mTouchDown + mOffset));            }            */        }    }    Handler FlingHandler = new Handler();    private long timeBegin = 0;    private long timeFling = 0;    private Runnable FlingRunnable = new Runnable() {        @Override        public void run() {            timeFling = System.currentTimeMillis() - timeBegin;            int delta = (int) ((mFlingVelocity + 0.0f) / (60)); // khung hình tiếp theo sẽ di chuyển từng này            if (mFlingVelocity > delta) { // ?                mFlingVelocity -= delta;            } else if (mFlingVelocity < -delta) {                mFlingVelocity -= delta;            } else {                mFlingVelocity = 0;            }            calculateAndInvalidate(currentWavePos - delta);            if (mFlingVelocity != 0) {                isFlingTransiting = true;                FlingHandler.post(FlingRunnable);            } else isFlingTransiting = false;        }    };    private boolean isFlingTransiting = false;    protected void doFlingTransition() {        if (isFlingTransiting) {            // Vào đây nghĩa là 1 fling đang chồng lên mà fling trước chưa chạy xong            //  Ta sẽ huỷ fling cũ đi để chạy fling mới.        }        // bắt đầu một fling mới        timeBegin = System.currentTimeMillis();        isFlingTransiting = true;        FlingHandler.post(FlingRunnable);    }    /**     * Call this to draw the wave form     *     * @param currentWavePos the position of the scroller in pixel unit     */    protected void calculateAndInvalidate(float currentWavePos) {        if (currentWavePos > ruler) currentWavePos = ruler;        else if (currentWavePos < 0) currentWavePos = 0;        this.currentWavePos = currentWavePos; // ?        translateX = (int) (mSeekBarCenter.X - this.currentWavePos);        float percentage = this.currentWavePos / ruler;        if (percentage < 0) percentage = 0;        else if (percentage > 1) percentage = 1;        lineFrom = (int) (percentage * getTotalPens() - getNumberPensAppearInScreen() / 2.0f - 10);        lineTo = (int) (percentage * getTotalPens() + getNumberPensAppearInScreen() / 2.0f + 10);        if (lineFrom < 0) lineFrom = 0;        if (lineTo > getTotalPens()) lineTo = getTotalPens();        //Log.d(TAG, "percent = " + percentage + ", lineFrom = " + lineFrom + ", lineTo = " + lineTo);        invalidate(); // TODO :  should  we doDraw all the view?    }    private boolean runningTrailer = false;    ValueAnimator va;    protected void startSlidingSeekBarEffect() {        runningTrailer = true;        va = ValueAnimator.ofFloat(0, ruler);        va.setInterpolator(new LinearInterpolator());        va.setDuration(mSongDeclareDuration);        va.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {            @Override            public void onAnimationUpdate(ValueAnimator animation) {                float value = (float) animation.getAnimatedValue();                calculateAndInvalidate(value);            }        });        va.start();    }    protected float mOneDp;    protected int mWidth = Tool.getScreenSize(App.getInstance())[0];    protected int mHeight = 0;    protected final MPoint mSeekBarCenter = new MPoint(0, 0);    protected final MPoint mRectCenter = new MPoint(0, 0);    @Override    protected void onSizeChanged(int w, int h, int oldw, int oldh) {        super.onSizeChanged(w, h, oldw, oldh);        mWidth = w;        mHeight = h;        lineHeight = maxLineHeight = top_bottom_ratio * (mHeight / 2.0f - mOneDp);        mMinSeekBarHeight = min_seek_value * (mHeight / 2.0f - mOneDp);        mMaxSeekHeight = max_seek_value * (mHeight / 2.0f - mOneDp);        mSeekBarCenter.X = (float) mWidth / 2;        mSeekBarCenter.Y = (float) mHeight / 2;        updateDrawProperties();        mSeekBarParser.viewSizeChanged(w, h);    }    private boolean isValidProperties() {        return mWidth > 0 && mHeight > 0;    }    protected Paint mActivePaint;    protected Paint mTranslucentActivePaint;    protected Paint mHidePaint;    protected Paint mTranslucentHidePaint;    public Paint mLinearPaint;    protected double nextDelayedTime = 30;    protected double ppPointCount = 0;    protected double ppPoint = 0;    protected boolean ppWaveDirection = true;    protected double ppTimeWaveDuration = 700.f;    protected final Interpolator ppInterpolator = new FastOutLinearInInterpolator();    protected Runnable mDrawInvalidationRunnable = new Runnable() {        @Override        public void run() {            calculating();            invalidate();            // the drawing flag            // if state is different from STATE.VISUALIZING, the draw invalidation will not repeat            if (mState == State.VISUALIZING)                return;            mHandler.postDelayed(mDrawInvalidationRunnable, (long) nextDelayedTime);        }    };    protected void updateCanvas(Canvas canvas) {        switch (mState) {            case NOTHING:                onDrawNothing(canvas);                break;            case PREPARING:                onDrawPreparing(canvas);                break;            case VISUALIZING:                onDrawVisualizing(canvas);                break;            case ON_SEEKING:                onDrawOnSeek(canvas);                break;            case SWITCHING:                onDrawSwitching(canvas);                break;            default:                break;        }    }    protected void calculating() {        switch (mState) {            case NOTHING:                onCalculateNothing();                break;            case PREPARING:                onCalculatePreparing();                break;            case VISUALIZING:                onCalculateVisualizing();                break;            case SWITCHING:                onCalculateSwitching();                break;            default:                break;        }    }    protected void onCalculateNothing() {    }    protected void format() {        switch (mState) {            case NOTHING:                formatStateNothing();                break;            case PREPARING:                formatPreparing();                break;            case VISUALIZING:                formatVisualizing();                break;            case SWITCHING:                formatSwitching();                break;            default:                break;        }    }    protected void formatPreparing() {        ppPoint = 0;        ppWaveDirection = true;        ppPointCount = 0;        ppTimeWaveDuration = 700;        nextDelayedTime = 30;    }    protected void formatStateNothing() {    }    protected void formatVisualizing() {        currentFractionComplete = 0;        mPenWidth = (float) (mPenDistance + mPenStrokeWidth);        // Chiều dài thực của visualSeekbar        WaveLength = (int) (mPenWidth * getTotalPens());    }    protected void formatSwitching() {    }    protected void onCalculatePreparing() {        if (currentFractionComplete >= 1            //        && ((pp_point >= 0.5f && pp_way) || (pp_point <= 0.5f && !pp_way))        )            processCommand(Command.PREPARED_ALREADY);        else { // do work            if (ppPointCount >= ppTimeWaveDuration / nextDelayedTime) {                ppPointCount = 0;                ppWaveDirection = !ppWaveDirection;            }            ppPointCount++;            //Log.d(TAG, "onCalculatePreparing: pp_counting = "+pp_point_counting +" / "+(pp_timeOneRound/nextDelayedTime));            ppPoint = ppPointCount / (ppTimeWaveDuration / nextDelayedTime);            ppPoint = ppInterpolator.getInterpolation((float) ppPoint);            if (!ppWaveDirection) ppPoint = 1 - ppPoint;            //  Log.d(TAG,pp_point_counting+" & "+pp_point);        }    }    protected void onCalculateVisualizing() {    }    protected void onCalculateSwitching() {    }    protected float tape = 0.01f;    protected float cross = 0.1f;    protected final int[] mLinearColors = new int[]{            0xff00dbde,            0xfffc00ff    };    @NonNull    private LinearGradient getLinearShader() {        int color_2 = Tool.getBaseColor();        int color_1 = Color.argb(0x22, Color.red(color_2), Color.green(color_2), Color.blue(color_2));        int[] color = new int[]{                color_1,                color_2,                color_2,                color_1        };        float sum = tape + 2 * cross;        float[] pos = new float[]{                0,                cross / sum,                1 - cross / sum,                1        };        return new LinearGradient(-sum * mWidth / 2, 0, sum * mWidth / 2, 0, color, pos,                Shader.TileMode.CLAMP);    }    protected void onDrawNothing(Canvas canvas) {    }    /**     * Draw a linear line that represents a loading effect     */    protected void onDrawPreparing(Canvas canvas) {        // canvas.drawLine(0,(float)mSeekBarCenter.Y,(float) (mWidth*currentFractionComplete),(float)mSeekBarCenter.Y,mActivePaint);        canvas.save();        canvas.translate((float) (ppPoint * mWidth), (float) mSeekBarCenter.Y);        canvas.drawLine((float) (-ppPoint * mWidth), 0, (float) (mWidth - ppPoint * mWidth), 0, mLinearPaint);        canvas.restore();    }    public int currentSeek = 0;    private boolean in_on_seek = false;    private boolean in_animate = false;    private ValueAnimator switch_state_va;    /* Draw the visual seek bar and the seeking animation */    protected void onDrawVisualizing(Canvas canvas) {        if (in_on_seek) {            if (in_animate) {                if (switch_state_va != null && switch_state_va.isRunning())                    switch_state_va.cancel();                in_animate = false;            }            in_animate = true;            in_on_seek = false;            switch_state_va = ValueAnimator.ofFloat(mOnSeekingAnimationFractionValue, 0);            switch_state_va.setInterpolator(InterpolatorUtil.getInterpolator(4));            //   switch_state_va.setInterpolator(new FeaturePlaylistAdapter.BounceInterpolator(0.1f,30));            switch_state_va.setDuration(350);            switch_state_va.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {                @Override                public void onAnimationUpdate(ValueAnimator valueAnimator) {                    mOnSeekingAnimationFractionValue = (float) valueAnimator.getAnimatedValue();                    if (mOnSeekingAnimationFractionValue == 0) {                        in_animate = false;                    }                    invalidate();                }            });            switch_state_va.start();        }        if (mOnSeekingAnimationFractionValue == 0)            drawVisualWave(canvas, currentSeek);        else            drawVisualWaveOnSeek(canvas, currentSeek);    }    protected void onDrawOnSeek(Canvas canvas) {        if (!in_on_seek) {            if (in_animate) {                if (switch_state_va != null && switch_state_va.isRunning())                    switch_state_va.cancel();            }            in_animate = true;            in_on_seek = true;            switch_state_va = ValueAnimator.ofFloat(mOnSeekingAnimationFractionValue, 1);            switch_state_va.setInterpolator(InterpolatorUtil.getInterpolator(4));            //     switch_state_va.setInterpolator(new FeaturePlaylistAdapter.BounceInterpolator(0.1f,30));            switch_state_va.setDuration(350);            switch_state_va.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {                @Override                public void onAnimationUpdate(ValueAnimator valueAnimator) {                    mOnSeekingAnimationFractionValue = (float) valueAnimator.getAnimatedValue();                    if (mOnSeekingAnimationFractionValue == 1) in_animate = false;                    invalidate();                }            });            switch_state_va.start();        }        drawVisualWaveOnSeek(canvas, currentSeek);    }    // normal pen= 4/7f    float min_seek_value = 3 / 8f;    float max_seek_value = 10 / 15f;    /**     * When user touches the seek bar, this value increases from 0 to 1.     * The Visual Seek Bar will use this value to make a animation at starting and finishing seeking event.     */    float mOnSeekingAnimationFractionValue = 0; //0 up to 1    float mMinSeekBarHeight, mMaxSeekHeight;    // hàm thực hiện vẽ wave khi đang seek bởi người dùng    // nằm càng xa tâm thì sẽ càng nhỏ    protected void drawVisualWaveOnSeek(Canvas canvas, int millisecond) {        // Tại thời điểm T, tương ứng với đoạn :        float mCurrentSeekPos = WaveLength / (mSongDeclareDuration + 0.0f) * millisecond;        // Chiều rộng của view là mWidth        float move;        // Nếu như SeekPos nhỏ hơn một nửa độ rộng, ta không cần di chuyển        if (mCurrentSeekPos <= mWidth / 2f) {            move = 0;        } else { // còn nếu SeekPos lớn hơn một nửa độ rộng            // Ta cần dịch sang trái một đoạn sao cho SeekPos ở chính giữa theo chiều ngang            move = mCurrentSeekPos - mWidth / 2f;        }        // Tiếp theo ta vẽ đoạn visual có thể thấy đc lên view        // Nghĩa là vẽ đoạn visual từ vị trí move tới vị trí SeekPos + mWidth /2        // Ta tính xem những Pen nào thì sẽ xuất hiện trong view, và ta chỉ vẽ chúng mà thôi        int firstPen = (int) (move / mPenWidth);        /*         * This is the index of the middle pen         * (which is the pen of the current seek bar value)         */        int mMiddlePenIndex = (int) (mCurrentSeekPos / mPenWidth);        int endPen = (int) ((move + mWidth) / mPenWidth);        for (int i = firstPen; i <= endPen && i != getTotalPens() - 1; i++) {            // càng cách xa midPen, kích thước càng nhỏ            float runtime_height;            // chiều dài thường       (0 -> 1)            float pen_pos = -move + mPenWidth * i + mPenWidth / 2;            // 1 <-> 0 <-> 1            float delta = (float) ((pen_pos < mWidth / 2f) ? (Math.pow((mWidth / 2f - pen_pos) / (mWidth / 2f), 3)) : (Math.pow((pen_pos - mWidth / 2f) / (mWidth / 2), 3)));            //  float delta = (float) ((pen_pos<mWidth/2) ?(Math.sqrt((mWidth/2 - pen_pos)/(mWidth/2))) :  Math.sqrt((pen_pos- mWidth/2)/(mWidth/2)));            /*                runtime_height = (float) (lineHeight                        - on_seek_animate_value //gia tăng theo animation                                        *delta // gia tăng theo vị trí pen, càng xa tâm thì càng tiến gần 1                                        *(lineHeight - min_seek_height)); // hằng số                                        */            float min_max_delta = mMaxSeekHeight - mMinSeekBarHeight;            // ở chính tâm thì có độ lớn là max_seek_height,            // ở ngoài cùng thì có độ lớn là min_seek_height            runtime_height = mMaxSeekHeight - delta * min_max_delta;            runtime_height = (runtime_height - lineHeight) * mOnSeekingAnimationFractionValue + lineHeight;            double alpha_delta = 1 - Math.pow(delta, 4) * 0.85 * mOnSeekingAnimationFractionValue;            //  double alpha_delta =1 -  Math.pow(delta,4)*0.85;            if (alpha_delta > 1) alpha_delta = 1;            mActivePaint.setAlpha((int) (255 * alpha_delta));            mTranslucentActivePaint.setAlpha((int) (255 * amount_translucent_paint * alpha_delta));            mHidePaint.setAlpha((int) (255 * amount_hide_paint * alpha_delta));            mTranslucentHidePaint.setAlpha((int) (255 * amount_translucent_hide_paint * alpha_delta));            float translationXSeekBarValue = 0;            if (mCurrentSeekPos <= mWidth / 2f) {                translationXSeekBarValue = (mWidth / 2f - mCurrentSeekPos) * mOnSeekingAnimationFractionValue;                // translationXSeekBarValue = mState == State.ON_SEEKING ? mWidth/2f - mCurrentSeekPos : 0;            } else { // còn nếu SeekPos lớn hơn một nửa độ rộng                // Ta cần dịch sang trái một đoạn sao cho SeekPos ở chính giữa theo chiều ngang                translationXSeekBarValue = mWidth / 2f - mCurrentSeekPos;            }            if (i < mMiddlePenIndex) {                // the previous pen line                // draw the above line                canvas.drawLine(                        (float) (translationXSeekBarValue + mPenWidth * i + mPenWidth / 2),                        (float) (mSeekBarCenter.Y - mOneDp),                        (float) (translationXSeekBarValue + mPenWidth * i + mPenWidth / 2),                        (float) (mSeekBarCenter.Y - mOneDp - runtime_height * getSmoothedPenGain(i)),                        mActivePaint);                // draw the below line                canvas.drawLine(                        (float) (translationXSeekBarValue + mPenWidth * i + mPenWidth / 2),                        (float) (mSeekBarCenter.Y + mOneDp),                        (float) (translationXSeekBarValue + mPenWidth * i + mPenWidth / 2),                        (float) (mSeekBarCenter.Y + mOneDp + runtime_height * getSmoothedPenGain(i)),                        mTranslucentActivePaint);            } else if (i > mMiddlePenIndex) {                // the after pen line                canvas.drawLine(                        (float) (translationXSeekBarValue + mPenWidth * i + mPenWidth / 2),                        (float) (mSeekBarCenter.Y - mOneDp),                        (float) (translationXSeekBarValue + mPenWidth * i + mPenWidth / 2),                        (float) (mSeekBarCenter.Y - mOneDp - runtime_height * getSmoothedPenGain(i)),                        mHidePaint);                canvas.drawLine(                        (float) (translationXSeekBarValue + mPenWidth * i + mPenWidth / 2),                        (float) (mSeekBarCenter.Y + mOneDp),                        (float) (translationXSeekBarValue + mPenWidth * i + mPenWidth / 2),                        (float) (mSeekBarCenter.Y + mOneDp + runtime_height * getSmoothedPenGain(i)),                        mTranslucentHidePaint);            } else {                if (mMiddlePenIndex * mPenWidth + mPenWidth - mPenDistance / 2 > mCurrentSeekPos) {                    canvas.drawRect(                            translationXSeekBarValue + mCurrentSeekPos,                            (float) (mSeekBarCenter.Y - mOneDp - runtime_height * getSmoothedPenGain(i)),                            (float) (translationXSeekBarValue + mMiddlePenIndex * mPenWidth + mPenWidth - mPenDistance / 2),                            (float) mSeekBarCenter.Y - mOneDp,                            mHidePaint                    );                    canvas.drawRect(                            translationXSeekBarValue + mCurrentSeekPos,                            (float) mSeekBarCenter.Y + mOneDp,                            (float) (translationXSeekBarValue + mMiddlePenIndex * mPenWidth + mPenWidth - mPenDistance / 2),                            (float) (mSeekBarCenter.Y + mOneDp + runtime_height * getSmoothedPenGain(i)),                            mTranslucentHidePaint                    );                }                if (mMiddlePenIndex * mPenWidth + mPenDistance / 2 < mCurrentSeekPos) {                    canvas.drawRect(                            (float) (translationXSeekBarValue + mPenWidth * mMiddlePenIndex + mPenDistance / 2),                            (float) (mSeekBarCenter.Y - mOneDp - runtime_height * getSmoothedPenGain(i)),                            (float) (translationXSeekBarValue + mCurrentSeekPos),                            (float) mSeekBarCenter.Y - mOneDp,                            mActivePaint);                    canvas.drawRect(                            (float) (translationXSeekBarValue + mPenWidth * mMiddlePenIndex + mPenDistance / 2),                            (float) mSeekBarCenter.Y + mOneDp,                            translationXSeekBarValue + mCurrentSeekPos,                            (float) (mSeekBarCenter.Y + mOneDp + runtime_height * getSmoothedPenGain(i)),                            mTranslucentActivePaint);                }            }        }    }    /**     * currentWavePos is in range [0;ruler], in pixel unit     */    protected float ruler = 0;    protected float currentTime = 0;    protected float currentWavePos = 0.0f;    private float touchDownPos = 0;    private float currentTouchPos;    private int touchDownMove = 0;    private int touchDownFling = 0;    private int lineFrom = 0, lineTo = 0;    private int deltaX = 0;    private int translateX = 0;    // tỉ lệ về độ cao của line trên so với height/2    private float top_bottom_ratio = 9 / 15f;    private float maxLineHeight;    private float lineHeight;    public float getCurrentTimeFromPos(float currentPos) {        return 0;    }    /**     * called by {@link #onDrawVisualizing};     *     * @param canvas the canvas of view.     */    // Mỗi "chiều cao của một pen" là một SmoothPenGain[i]    // Có tất cả TotalPenGains    // Mỗi đường được biểu diễn là một hình chữ nhật    // có    // width = strokeWidthPen + distancePen = 4dp =  ( 3 + 0.5. 0.5 )    // height = lineHeight* SmoothedPenGain[i]    // ở tâm vẽ một đường thẳng    /**     * Vẽ một visual wave nơi nó thể hiện cường độ âm thanh tại thời điểm millisecond     *     * @param canvas     * @param millisecond     */    float mPenWidth;    float WaveLength;    protected void drawVisualWave(Canvas canvas, int millisecond) {        mActivePaint.setAlpha(255);        mTranslucentActivePaint.setAlpha((int) (255 * amount_translucent_paint));        mHidePaint.setAlpha((int) (255 * amount_hide_paint));        mTranslucentHidePaint.setAlpha((int) (255 * amount_translucent_hide_paint));        // Tại thời điểm T, tương ứng với đoạn :        float mCurrentSeekPos = WaveLength / (mSongDeclareDuration + 0.0f) * millisecond;        // Chiều rộng của view là mWidth        float move;        // Nếu như SeekPos nhỏ hơn một nửa độ rộng, ta không cần di chuyển        if (mCurrentSeekPos <= mWidth / 2f) {            move = 0;        } else { // còn nếu SeekPos lớn hơn một nửa độ rộng            // Ta cần dịch sang trái một đoạn sao cho SeekPos ở chính giữa theo chiều ngang            move = mCurrentSeekPos - mWidth / 2f;        }        // Tiếp theo ta vẽ đoạn visual có thể thấy đc lên view        // Nghĩa là vẽ đoạn visual từ vị trí move tới vị trí SeekPos + mWidth /2        // Ta tính xem những Pen nào thì sẽ xuất hiện trong view, và ta chỉ vẽ chúng mà thôi        int firstPen = (int) (move / mPenWidth);        int midPen = (int) (mCurrentSeekPos / mPenWidth);        int endPen = (int) ((move + mWidth) / mPenWidth);        double smoothedPenGainValue;        for (int i = firstPen; i <= endPen && i != getTotalPens() - 1 && i < getSmoothedPenGain().length; i++) {            smoothedPenGainValue = getSmoothedPenGain(i);            if (i < midPen) {                canvas.drawLine(                        (float) (-move + mPenWidth * i + mPenWidth / 2),                        (float) (mSeekBarCenter.Y - mOneDp),                        (float) (-move + mPenWidth * i + mPenWidth / 2),                        (float) (mSeekBarCenter.Y - mOneDp - lineHeight * smoothedPenGainValue),                        mActivePaint);                canvas.drawLine(                        (float) (-move + mPenWidth * i + mPenWidth / 2),                        (float) (mSeekBarCenter.Y + mOneDp),                        (float) (-move + mPenWidth * i + mPenWidth / 2),                        (float) (mSeekBarCenter.Y + mOneDp + lineHeight * smoothedPenGainValue),                        mTranslucentActivePaint);            } else if (i > midPen) {                canvas.drawLine(                        (float) (-move + mPenWidth * i + mPenWidth / 2),                        (float) (mSeekBarCenter.Y - mOneDp),                        (float) (-move + mPenWidth * i + mPenWidth / 2),                        (float) (mSeekBarCenter.Y - mOneDp - lineHeight * smoothedPenGainValue),                        mHidePaint);                canvas.drawLine(                        (float) (-move + mPenWidth * i + mPenWidth / 2),                        (float) (mSeekBarCenter.Y + mOneDp),                        (float) (-move + mPenWidth * i + mPenWidth / 2),                        (float) (mSeekBarCenter.Y + mOneDp + lineHeight * smoothedPenGainValue),                        mTranslucentHidePaint);            } else {                if (midPen * mPenWidth + mPenWidth - mPenDistance / 2 > mCurrentSeekPos) {                    canvas.drawRect(                            -move + mCurrentSeekPos,                            (float) (mSeekBarCenter.Y - mOneDp - lineHeight * smoothedPenGainValue),                            (float) (-move + midPen * mPenWidth + mPenWidth - mPenDistance / 2),                            (float) mSeekBarCenter.Y - mOneDp,                            mHidePaint                    );                    canvas.drawRect(                            -move + mCurrentSeekPos,                            (float) mSeekBarCenter.Y + mOneDp,                            (float) (-move + midPen * mPenWidth + mPenWidth - mPenDistance / 2),                            (float) (mSeekBarCenter.Y + mOneDp + lineHeight * smoothedPenGainValue),                            mTranslucentHidePaint                    );                }                if (midPen * mPenWidth + mPenDistance / 2 < mCurrentSeekPos) {                    canvas.drawRect(                            (float) (-move + mPenWidth * midPen + mPenDistance / 2),                            (float) (mSeekBarCenter.Y - mOneDp - lineHeight * smoothedPenGainValue),                            (float) (-move + mCurrentSeekPos),                            (float) mSeekBarCenter.Y - mOneDp,                            mActivePaint);                    canvas.drawRect(                            (float) (-move + mPenWidth * midPen + mPenDistance / 2),                            (float) mSeekBarCenter.Y + mOneDp,                            -move + mCurrentSeekPos,                            (float) (mSeekBarCenter.Y + mOneDp + lineHeight * smoothedPenGainValue),                            mTranslucentActivePaint);                }            }        }    }    private final SwipeDetectorGestureListener mSwipeDetectorListener = new SwipeDetectorGestureListener() {        @Override        public void onUp(MotionEvent e) {            Log.d(TAG, "onUp");            if (inFling) {                return;            }            restoreOldState();            if (mSeekBarListener != null) {                int seek = currentSeek;                if (currentSeek < 0) {                    seek = 0;                } else if (currentSeek > mSongDeclareDuration) {                    seek = mSongDeclareDuration;                }                mSeekBarListener.onSeekBarSeekTo(AudioVisualSeekBar.this, seek);                mSeekBarListener.onSeekBarTouchUp(AudioVisualSeekBar.this);            }        }        @Override        public boolean onSingleTapUp(MotionEvent e) {            Log.d(TAG,"onSingleTapUp");            return super.onSingleTapUp(e);        }        @Override        public void onLongPress(MotionEvent e) {            Log.d(TAG,"onLongPress");            super.onLongPress(e);        }        private void setStateSeekingAndSaveOldState() {            if (mState != State.ON_SEEKING) {                savedState = mState;                mState = State.ON_SEEKING;                invalidate();            }        }        @Override        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {            /*            Sự kiện kéo            Ta dịch chuyển thanh ngay tức thì             */            if (inFling) {                flingAnimation.cancel();                inFling = false;            }            setStateSeekingAndSaveOldState();            float ms_seek = distanceX / WaveLength * (mSongDeclareDuration + 0.0f);            float newSeek = currentSeek + ms_seek;            if (newSeek <= 0) {                newSeek = 0;            } else if (newSeek >= mSongDeclareDuration) {                newSeek = mSongDeclareDuration - 1000;            }                currentSeek = (int) newSeek;            if (mSeekBarListener != null) {                mSeekBarListener.onSeekBarSeeking(currentSeek);            }            invalidate();            return super.onScroll(e1, e2, distanceX, distanceY);        }        @Override        public boolean onFling(MotionEvent e1, MotionEvent e2, float vx, float vy) {            //Log.d(TAG,"onFling");            boolean d;            try {                d = super.onFling(e1, e2, vx, vy);            } catch (Exception e) {                d = false;            }            //     restoreState();            return d;        }        @Override        public void onShowPress(MotionEvent e) {            //Log.d(TAG,"onShowPress");        }        @Override        public boolean onSwipeRight(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {            //Log.d(TAG,"onSwipeRight");            return onSwipeHandler(e1, e2, velocityX, velocityY);        }        @Override        public boolean onSwipeLeft(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {            //Log.d(TAG,"onSwipeLeft ");            return onSwipeHandler(e1, e2, velocityX, velocityY);        }        boolean inFling = false;        FlingAnimation flingAnimation;        private boolean onSwipeHandler(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {            if (inFling) {                flingAnimation.cancel();            }            inFling = true;            flingAnimation = new FlingAnimation(new FloatValueHolder(0));            int saved = currentSeek;            setStateSeekingAndSaveOldState();            flingAnimation.addUpdateListener(new DynamicAnimation.OnAnimationUpdateListener() {                @Override                public void onAnimationUpdate(DynamicAnimation animation, float value, float velocity) {                    currentSeek = (int) (saved + value / WaveLength * (mSongDeclareDuration + 0.0f));                    if (currentSeek < 0) {                        currentSeek = 0;                    } else if (currentSeek > mSongDeclareDuration) {                        currentSeek = mSongDeclareDuration - 1000;                    }                    if (mSeekBarListener != null) {                        mSeekBarListener.onSeekBarSeeking(currentSeek);                    }                    //    Log.d(TAG, "value = " + value);                    invalidate();                }            });            flingAnimation.addEndListener(new DynamicAnimation.OnAnimationEndListener() {                @Override                public void onAnimationEnd(DynamicAnimation animation, boolean canceled, float value, float velocity) {                    inFling = false;                    restoreOldState();                    if (mSeekBarListener != null) {                        int seek = currentSeek;                        if (currentSeek < 0) seek = 0;                        else if (currentSeek > mSongDeclareDuration)                            seek = mSongDeclareDuration;                        mSeekBarListener.onSeekBarSeekTo(AudioVisualSeekBar.this, seek);                        mSeekBarListener.onSeekBarTouchUp(AudioVisualSeekBar.this);                    }                }            });            flingAnimation                    .setFriction(2f)                    .setStartVelocity(-velocityX)                    //  .setMinValue(-currentWavePos)                    //     .setMaxValue(WaveLength- currentWavePos)                    //.setStartValue(currentSeek)                    .start();            return true;        }        @Override        public boolean onSwipeTop(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {            //Log.d(TAG,"onSwipeTop");            return false;        }        @Override        public boolean onSwipeBottom(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {            //Log.d(TAG,"onSwipeBottom");            return false;        }        private State savedState;        @Override        public boolean onDown(MotionEvent e) {            Log.d(TAG, "onDown ");            setStateSeekingAndSaveOldState();            if (mSeekBarListener != null) {                mSeekBarListener.onSeekBarTouchDown(AudioVisualSeekBar.this);            }            return true;        }        @Override        public boolean onDoubleTap(MotionEvent e) {            Log.d(TAG,"onDoubleTap");            return super.onDoubleTap(e);        }        private void restoreOldState() {            mState = savedState;            invalidate();        }        @Override        public boolean onSingleTapConfirmed(MotionEvent e) {            Log.d(TAG, "onSingleTapConfirmed");            return false;        }    };    protected void initGestureDetector(Context context) {        mGestureDetector = new GestureDetector(                context,                mSwipeDetectorListener);        mGestureDetector.setIsLongpressEnabled(false);    }    protected GestureDetector mGestureDetector;    public static class SwipeDetectorGestureListener extends GestureDetector.SimpleOnGestureListener {        private static final int SWIPE_THRESHOLD = 100;        private static final int SWIPE_VELOCITY_THRESHOLD = 100;        public void onUp(MotionEvent e) {        }        @Override        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {            boolean result = false;            if (e1 == null || e2 == null) return false;            try {                float diffY = e2.getY() - e1.getY();                float diffX = e2.getX() - e1.getX();                if (Math.abs(diffX) > Math.abs(diffY)) {                    if (Math.abs(diffX) > SWIPE_THRESHOLD && Math.abs(velocityX) > SWIPE_VELOCITY_THRESHOLD) {                        if (diffX > 0) {                            result = onSwipeRight(e1, e2, velocityX, velocityY);                        } else {                            result = onSwipeLeft(e1, e2, velocityX, velocityY);                        }                    }                } else {                    if (Math.abs(diffY) > SWIPE_THRESHOLD && Math.abs(velocityY) > SWIPE_VELOCITY_THRESHOLD) {                        if (diffY > 0) {                            result = onSwipeBottom(e1, e2, velocityX, velocityY);                        } else {                            result = onSwipeTop(e1, e2, velocityX, velocityY);                        }                    }                }            } catch (Exception exception) {                exception.printStackTrace();            }            return result;        }        public boolean onSwipeRight(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {            return true;        }        public boolean onSwipeLeft(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {            return true;        }        public boolean onSwipeTop(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {            return true;        }        public boolean onSwipeBottom(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {            return true;        }    }    @Override    public boolean onTouchEvent(MotionEvent event) {        performClick();/*        if(event.getAction()==MotionEvent.ACTION_DOWN)        Log.d(TAG, "onTouchEvent DOWN");        else Log.d(TAG, "onTouchEvent: "+event.getAction());*/        boolean handled = false;        try {            handled = mGestureDetector.onTouchEvent(event);        } catch (Exception ignored) {        }        if (event.getAction() == MotionEvent.ACTION_UP) {            mSwipeDetectorListener.onUp(event);        }        return handled || super.onTouchEvent(event);    }    @Override    public boolean performClick() {        return super.performClick();    }    protected void onDrawSwitching(Canvas canvas) {    }    @Override    protected void onDraw(Canvas canvas) {        super.onDraw(canvas);        try {            updateCanvas(canvas);        } catch (Exception ignore) {        }    }    /*        NOTHING: It means that SeekBar now do not show visualization, it is just a normal seek bar.        PREPARING: A Sound File is being parsed by its and will show a visualization when it finishes.        VISUALIZING:  VISUALIZING is being showed        SWITCHING: Close Effect is being showed to prepare for a new sound file.         */    enum State {        NOTHING,        PREPARING,        VISUALIZING,        ON_SEEKING,        SWITCHING    }    enum Command {        FILE_SET,        BEGIN,        PREPARED_ALREADY    }    private State mState = State.NOTHING;    private void processCommand(Command command) {        switch (command) {            case FILE_SET:                if (mState == State.NOTHING)                    onBeginPreparing();                else if (mState == State.VISUALIZING)                    onBeginSwitching();                break;            case BEGIN:                mState = State.NOTHING;                break;            case PREPARED_ALREADY:                onBeginVisualizing();                break;            default:                break;        }    }    boolean updateParsingProgress(double fraction) {        currentFractionComplete = fraction;        //   Log.d(TAG,"frac = "+currentFractionComplete);        return mLoadingKeepGoing;    }    protected double currentFractionComplete = 0;    protected boolean loadingFalse = false;    private final VisualSeekBarParser mSeekBarParser = new VisualSeekBarParser(this);    // create new sound file.    void onBeginPreparing() {        mHandler.postDelayed(mDrawInvalidationRunnable, (long) nextDelayedTime);        mState = State.PREPARING;        format();        loadingFalse = false;        mSeekBarParser.parse(mSong);    }    /**     * Called by parser     */    void startParsingFile() {        processCommand(Command.FILE_SET);    }    /**     * Called by parser     */    void finishParsingFile() {        ruler = (float) (getTotalPens() * mPenStrokeWidth + (getTotalPens() - 1) * mPenDistance);        currentWavePos = 0;        lineFrom = 0;        lineTo = getNumberPensAppearInScreen() / 2 + 10;        translateX = (int) (mSeekBarCenter.X - currentWavePos);        if (currentFractionComplete != 1) {            currentFractionComplete = 1;            ppTimeWaveDuration = 350;        }    }    // Or this    // Remove current cheap sound file and set a new one.    void onBeginSwitching() {        mState = State.SWITCHING;        format();        onBeginPreparing();    }    protected void onBeginVisualizing() {        mState = State.VISUALIZING;        format();    }    private int mTempProgress = 0;    public void visualize(Song song, long duration, int currentOffSet) {        Log.d(TAG, "visualize new song " + song.title);        /* Store sound file and base information */        mSong = song;        setSongDeclareDuration((int) duration);        if (currentOffSet < 0)            mTempProgress = 0;        else if (currentOffSet > duration) mTempProgress = (int) (duration - 1);        else mTempProgress = currentOffSet;        //  setProgress(mTempProgress);        updateDrawProperties();        try {            mSeekBarParser.parse(song);        } catch (Exception ignore) {        }    }    //protected long mLoadingLastUpdateTime = 0;    protected boolean mLoadingKeepGoing = true;    protected Song mSong;    public Song getCurrentSong() {        return mSong;    }    public int getCurrentSongID() {        return mSong == null ? 0 : (int) mSong.id;    }    protected final Handler mHandler = new Handler();    float mPenStrokeWidth;    double mPenDistance;    int getNumberPensAppearInScreen() {        return mSeekBarParser.mNumberPensAppearInScreen;    }    int getTotalPens() {        return mSeekBarParser.mTotalPens;    }    double[] getSmoothedPenGain() {        return mSeekBarParser.mSmoothedPenGain;    }    double getSmoothedPenGain(int position) {        return mSeekBarParser.mSmoothedPenGain[position];    }    /*    protected String secondsToMinutes(String seconds) {    }    */    private final float amount_translucent_paint = 0.588f;    public void updateDrawProperties() {        mLinearPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mLinearPaint.setShader(getLinearShader());        mLinearPaint.setStyle(Paint.Style.FILL_AND_STROKE);        mLinearPaint.setStrokeWidth(1.5f * mOneDp);        mLinearPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        mLinearPaint.setShader(getLinearShader());        mLinearPaint.setStyle(Paint.Style.FILL_AND_STROKE);        mLinearPaint.setStrokeWidth(1.5f * mOneDp);        mActivePaint.setColor(Tool.getBaseColor());        mTranslucentActivePaint.setColor(Tool.getBaseColor());        mTranslucentActivePaint.setAlpha((int) (amount_translucent_paint * 255));        int global = Tool.getMostCommonColor();        mLinearPaint.setShader(getLinearShader());        mHidePaint.setColor(Color.WHITE);        mHidePaint.setAlpha((int) (amount_hide_paint * 255));        mTranslucentHidePaint.setColor(Color.WHITE);        mTranslucentHidePaint.setAlpha((int) (amount_translucent_hide_paint * 255));    }    private float touchDownAlphaAdd = 0.2f;}